[TOC]





# 学习笔记

## 第二周作业

### 1 演练串行/并行/CMS/G1的案例

&ensp;&ensp;作业要求：使用GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例。 

### 2 使用压测工具sb

&ensp;&ensp;作业要求：使用压测工具（wrk 或 sb），演练 gateway-server-0.0.1-SNAPSHOT.jar 示例。 

### 3 不同GC的总结

​	&ensp;作业要求： 根据上述自己对于 1 和 2 的演示，写一段对于不同 GC 的总结，提交到 Github。 

#### 3.1 垃圾收集器分类：

##### 3.1.1 串行收集器->Serial和Serial Old

  1. 启用

      -XX：+UseSerialGC 

      -XX：+UseSerialOldGC

  2. 特点

        1. 只能有一个垃圾回收线程执行，用户线程暂停。

  3. 使用场景

        1. 适用于内存比较小的嵌入式设备 。

##### 3.1.2 并行收集器[吞吐量优先]->Parallel Scanvenge、Parallel Old

  1. 启用

      -XX：+UseParallelGC 

      -XX：+UseParallelOldGC

  2. 特点

        1. 多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。

  3. 使用场景

        1. 适用于科学计算、后台处理等若交互场景 。

##### 3.1.3 并发收集器[停顿时间优先]->CMS、G1
  1. 启用

      -XX：+UseConcMarkSweepGC 

      -XX：+UseG1GC

  2. 特点

        1. 用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的时候不会停顿用户线程的运行。

  3. 使用场景

        1. 适用于相对时间有要求的场景，比如Web 。

#### 3.2 **如何选择合适的垃圾收集器**：

##### 3.2.1 指导原则

  1. 优先调整堆的大小让服务器自己来选择

  2. 如果内存小于100M，使用串行收集器

  3. 如果是单核，并且没有停顿时间要求，使用串行或JVM自己选

  4. 如果允许停顿时间超过1秒，选择并行或JVM自己选

  5. 如果响应时间最重要，并且不能超过1秒，使用并发收集器

     

### 4. 运行Netty 例子，分析现象

&ensp;作业要求： 运行课上的例子，以及 Netty 的例子，分析相关现象。



### 5. 写HttpClient 或 OkHttp的demo

&ensp;作业要求： 写一段代码，使用 HttpClient 或 OkHttp 访问 [http://localhost:8801 ](http://localhost:8801/)，代码提交到 Github。

#### 5.1 HttpClient：

##### 5.1.1 指导原则

#### 5.2 **OkHttp**：

##### 5.2.1 指导原则







  * #### 参考文献
    
        1. https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28
        2. 
